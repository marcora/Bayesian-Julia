<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/Bayesian-Julia/libs/katex/katex.min.css"> <link rel=stylesheet  href="/Bayesian-Julia/libs/highlight/github.min.css"> <link rel=stylesheet  href="/Bayesian-Julia/css/jtd.css"> <link rel=icon  href="/Bayesian-Julia/assets/favicon.ico"> <title>Computational Tricks with Turing <br/> &#40;Non-Centered Parametrization <br/> and QR Decomposition&#41;</title> <div class=page-wrap > <div class=side-bar > <div class=header > <a href="/Bayesian-Julia/" class=title > Bayesian Stats </a> </div> <label for=show-menu  class=show-menu >MENU</label> <input type=checkbox  id=show-menu  role=button > <div class=menu  id=side-menu > <ul class=menu-list > <li class="menu-list-item "><a href="/Bayesian-Julia/" class="menu-list-link ">Home</a> <li class="menu-list-item "><a href="/Bayesian-Julia/pages/1_why_Julia/" class="menu-list-link ">1. Why Julia?</a> <li class="menu-list-item "><a href="/Bayesian-Julia/pages/2_bayes_stats/" class="menu-list-link ">2. What is Bayesian Statistics?</a> <li class="menu-list-item "><a href="/Bayesian-Julia/pages/3_prob_dist/" class="menu-list-link ">3. Common Probability Distributions</a> <li class="menu-list-item "><a href="/Bayesian-Julia/pages/4_Turing/" class="menu-list-link ">4. How to use Turing</a> <li class="menu-list-item "><a href="/Bayesian-Julia/pages/5_MCMC/" class="menu-list-link ">5. Markov Chain Monte Carlo (MCMC)</a> <li class="menu-list-item "><a href="/Bayesian-Julia/pages/6_linear_reg/" class="menu-list-link ">6. Bayesian Linear Regression</a> <li class="menu-list-item "><a href="/Bayesian-Julia/pages/7_logistic_reg/" class="menu-list-link ">7. Bayesian Logistic Regression</a> <li class="menu-list-item "><a href="/Bayesian-Julia/pages/8_count_reg/" class="menu-list-link ">8. Bayesian Regression with Count Data</a> <li class="menu-list-item "><a href="/Bayesian-Julia/pages/9_robust_reg/" class="menu-list-link ">9. Robust Bayesian Regression</a> <li class="menu-list-item "><a href="/Bayesian-Julia/pages/10_multilevel_models/" class="menu-list-link ">10. Multilevel Models</a> <li class="menu-list-item active"><a href="/Bayesian-Julia/pages/11_Turing_tricks/" class="menu-list-link active">11. Computational Tricks with Turing</a> <li class="menu-list-item "><a href="/Bayesian-Julia/pages/12_epi_models/" class="menu-list-link ">12. Bayesian Epidemiological Models</a> </ul> </div> <div class=footer > <a href="https://www.julialang.org"><img style="height:50px;padding-left:10px;margin-bottom:15px;" src="https://julialang.org/assets/infra/logo.svg" alt="Julia Logo"></a> </div> </div> <div class=main-content-wrap > <div class=main-content > <div class=main-header > <a id=github  href="https://github.com/storopoli/Bayesian-Julia">Code on GitHub</a> </div> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-186284914-6"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-186284914-6'); </script> <div class=franklin-content ><div class=franklin-toc ><ol><li><a href="#qr_decomposition">QR Decomposition</a><li><a href="#non-centered_parametrization">Non-Centered Parametrization</a><li><a href="#references">References</a></ol></div> <h1 id=computational_tricks_with_turing_non-centered_parametrization_and_qr_decomposition ><a href="#computational_tricks_with_turing_non-centered_parametrization_and_qr_decomposition" class=header-anchor >Computational Tricks with Turing <br/> &#40;Non-Centered Parametrization <br/> and QR Decomposition&#41;</a></h1> <p>There are some computational tricks that we can employ with Turing. I will cover here two computational tricks:</p> <ol> <li><p><strong>QR Decomposition</strong></p> <li><p><strong>Non-Centered Parametrization</strong></p> </ol> <h2 id=qr_decomposition ><a href="#qr_decomposition" class=header-anchor >QR Decomposition</a></h2> <p>Back in &quot;Linear Algebra 101&quot; we&#39;ve learned that any matrix &#40;even rectangular ones&#41; can be factored into the product of two matrices:</p> <ul> <li><p>\(\mathbf{Q}\): an orthogonal matrix &#40;its columns are orthogonal unit vectors meaning \(\mathbf{Q}^T = \mathbf{Q}^{-1})\).</p> <li><p>\(\mathbf{R}\): an upper triangular matrix.</p> </ul> <p>This is commonly known as the <a href="https://en.wikipedia.org/wiki/QR_decomposition"><strong>QR Decomposition</strong></a>:</p> \[ \mathbf{A} = \mathbf{Q} \cdot \mathbf{R} \] <p>Let me show you an example with a random matrix \(\mathbf{A} \in \mathbb{R}^{3 \times 2}\):</p> <pre><code class=language-julia >A &#61; rand&#40;3, 2&#41;</code></pre><pre><code class="plaintext code-output">3×2 Matrix{Float64}:
 0.615669  0.182872
 0.602221  0.805418
 0.936869  0.645826</code></pre> <p>Now let&#39;s factor <code>A</code> using <code>LinearAlgebra</code>&#39;s <code>qr&#40;&#41;</code> function:</p> <pre><code class=language-julia >using LinearAlgebra:qr, I
Q, R &#61; qr&#40;A&#41;</code></pre><pre><code class="plaintext code-output">LinearAlgebra.QRCompactWY{Float64, Matrix{Float64}}
Q factor:
3×3 LinearAlgebra.QRCompactWYQ{Float64, Matrix{Float64}}:
 -0.483798   0.604397  -0.632964
 -0.473231  -0.78905   -0.39173
 -0.736201   0.11002    0.667761
R factor:
2×2 Matrix{Float64}:
 -1.27257  -0.94508
  0.0      -0.453934</code></pre> <p>Notice that <code>qr&#40;&#41;</code> produced a tuple containing two matrices <code>Q</code> and <code>R</code>. <code>Q</code> is a 3x3 orthogonal matrix. And <code>R</code> is a 2x2 upper triangular matrix. So that \(\mathbf{Q}^T = \mathbf{Q}^{-1}\) &#40;the transpose is equal the inverse&#41;:</p> <pre><code class=language-julia >Matrix&#40;Q&#39;&#41; ≈ Matrix&#40;Q^-1&#41;</code></pre><pre><code class="plaintext code-output">true</code></pre>
<p>Also note that \(\mathbf{Q}^T \cdot \mathbf{Q}^{-1} = \mathbf{I}\) &#40;identity matrix&#41;:</p>
<pre><code class=language-julia >Q&#39; * Q ≈ I&#40;3&#41;</code></pre><pre><code class="plaintext code-output">true</code></pre>
<p>This is nice. But what can we do with QR decomposition? It can speed up Turing&#39;s sampling by a huge factor while also decorrelating the columns of \(\mathbf{X}\), <em>i.e.</em> the independent variables. The orthogonal nature of QR decomposition alters the posterior&#39;s topology and makes it easier for HMC or other MCMC samplers to explore it. Let&#39;s see how fast we can get with QR decomposition. First, let&#39;s go back to the <code>kidiq</code> example in <a href="/Bayesian-Julia/pages/6_linear_reg/">6. <strong>Bayesian Linear Regression</strong></a>:</p>
<pre><code class=language-julia >using Turing
using Statistics: mean, std
using Random:seed&#33;
seed&#33;&#40;123&#41;

@model linreg&#40;X, y; predictors&#61;size&#40;X, 2&#41;&#41; &#61; begin
    #priors
    α ~ Normal&#40;mean&#40;y&#41;, 2.5 * std&#40;y&#41;&#41;
    β ~ filldist&#40;TDist&#40;3&#41;, predictors&#41;
    σ ~ Exponential&#40;1&#41;

    #likelihood
    y ~ MvNormal&#40;α .&#43; X * β, σ&#41;
end;

using DataFrames, CSV, HTTP

url &#61; &quot;https://raw.githubusercontent.com/storopoli/Bayesian-Julia/master/datasets/kidiq.csv&quot;
kidiq &#61; CSV.read&#40;HTTP.get&#40;url&#41;.body, DataFrame&#41;
X &#61; Matrix&#40;select&#40;kidiq, Not&#40;:kid_score&#41;&#41;&#41;
y &#61; kidiq&#91;:, :kid_score&#93;
model &#61; linreg&#40;X, y&#41;
chain &#61; sample&#40;model, NUTS&#40;&#41;, MCMCThreads&#40;&#41;, 2_000, 4&#41;</code></pre><pre><code class="plaintext code-output">Chains MCMC chain (2000×17×4 Array{Float64, 3}):

Iterations        = 1001:1:3000
Number of chains  = 4
Samples per chain = 2000
Wall duration     = 26.33 seconds
Compute duration  = 49.41 seconds
parameters        = α, β[1], β[2], β[3], σ
internals         = lp, n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size

Summary Statistics
  parameters      mean       std   naive_se      mcse         ess      rhat   ess_per_sec
      Symbol   Float64   Float64    Float64   Float64     Float64   Float64       Float64

           α   21.7294    8.5853     0.0960    0.1390   3485.3416    1.0004       70.5449
        β[1]    2.0249    1.7880     0.0200    0.0291   3122.9675    1.0010       63.2103
        β[2]    0.5799    0.0575     0.0006    0.0009   4521.7685    1.0004       91.5227
        β[3]    0.2411    0.3036     0.0034    0.0043   4183.4396    1.0000       84.6747
           σ   17.8769    0.5978     0.0067    0.0075   6158.8479    1.0008      124.6579

Quantiles
  parameters      2.5%     25.0%     50.0%     75.0%     97.5%
      Symbol   Float64   Float64   Float64   Float64   Float64

           α    4.9794   15.9707   21.6723   27.4182   38.6449
        β[1]   -0.6166    0.7170    1.7000    3.0248    6.3278
        β[2]    0.4667    0.5418    0.5809    0.6177    0.6928
        β[3]   -0.3610    0.0384    0.2422    0.4429    0.8434
           σ   16.7538   17.4746   17.8553   18.2619   19.1156
</code></pre>
<p>See the wall duration in Turing&#39;s <code>chain</code>: for me it took around 24 seconds.</p>
<p>Now let&#39;s us incorporate QR decomposition in the linear regression model. Here, I will use the &quot;thin&quot; instead of the &quot;fat&quot; QR, which scales the \(\mathbf{Q}\) and \(\mathbf{R}\) matrices by a factor of \(\sqrt{n-1}\) where \(n\) is the number of rows of \(\mathbf{X}\). In practice it is better to implement the thin QR decomposition, which is to be preferred to the fat QR decomposition. It is numerically more stable. Mathematically, the thin QR decomposition is:</p>
\[
\begin{aligned}
x &= \mathbf{Q}^* \mathbf{R}^* \\
\mathbf{Q}^* &= \mathbf{Q} \cdot \sqrt{n - 1} \\
\mathbf{R}^* &= \frac{1}{\sqrt{n - 1}} \cdot \mathbf{R}\\
\boldsymbol{\mu}
&= \alpha + \mathbf{X} \cdot \boldsymbol{\beta} + \sigma
\\
&= \alpha + \mathbf{Q}^* \cdot \mathbf{R}^* \cdot \boldsymbol{\beta} + \sigma
\\
&= \alpha + \mathbf{Q}^* \cdot (\mathbf{R}^* \cdot \boldsymbol{\beta}) + \sigma
\\
&= \alpha + \mathbf{Q}^* \cdot \widetilde{\boldsymbol{\beta}} + \sigma
\\
\end{aligned}
\]
<p>Then we can recover the original \(\boldsymbol{\beta}\) with:</p>
\[ \boldsymbol{\beta} = \mathbf{R}^{*-1} \cdot \widetilde{\boldsymbol{\beta}} \]
<p>In Turing, a model with QR decomposition would be the same <code>linreg</code> but with a different <code>X</code> matrix supplied, since it is a data transformation. First, we decompose your model data <code>X</code> into <code>Q</code> and <code>R</code>:</p>
<pre><code class=language-julia >Q, R &#61; qr&#40;X&#41;
Q_ast &#61; Matrix&#40;Q&#41; * sqrt&#40;size&#40;X, 1&#41; - 1&#41;
R_ast &#61; R / sqrt&#40;size&#40;X, 1&#41; - 1&#41;;</code></pre>
<p>Then, we instantiate a model with <code>Q</code> instead of <code>X</code> and sample as you would:</p>
<pre><code class=language-julia >model_qr &#61; linreg&#40;Q_ast, y&#41;
chain_qr &#61; sample&#40;model_qr, NUTS&#40;1_000, 0.65&#41;, MCMCThreads&#40;&#41;, 2_000, 4&#41;</code></pre><pre><code class="plaintext code-output">Chains MCMC chain (2000×17×4 Array{Float64, 3}):

Iterations        = 1001:1:3000
Number of chains  = 4
Samples per chain = 2000
Wall duration     = 10.66 seconds
Compute duration  = 21.2 seconds
parameters        = α, β[1], β[2], β[3], σ
internals         = lp, n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size

Summary Statistics
  parameters       mean       std   naive_se      mcse         ess      rhat   ess_per_sec
      Symbol    Float64   Float64    Float64   Float64     Float64   Float64       Float64

           α    33.2749    7.9295     0.0887    0.1678   2113.0783    1.0003       99.6970
        β[1]   -49.6645    7.0809     0.0792    0.1498   2117.7218    1.0003       99.9161
        β[2]    21.8955    3.6100     0.0404    0.0757   2147.1293    1.0002      101.3036
        β[3]     0.2928    0.9071     0.0101    0.0167   2942.9498    1.0001      138.8511
           σ    17.8676    0.5988     0.0067    0.0090   4805.0471    0.9999      226.7066

Quantiles
  parameters       2.5%      25.0%      50.0%      75.0%      97.5%
      Symbol    Float64    Float64    Float64    Float64    Float64

           α    18.4666    27.8142    32.9991    38.4474    49.3556
        β[1]   -63.0827   -54.5222   -49.8503   -45.0637   -35.2238
        β[2]    14.4705    19.5789    21.9879    24.3914    28.6957
        β[3]    -1.3998    -0.3152     0.2446     0.8594     2.2182
           σ    16.7584    17.4485    17.8652    18.2675    19.0575
</code></pre>
<p>See the wall duration in Turing&#39;s <code>chain_qr</code>: for me it took around 5 seconds. Much faster than the regular <code>linreg</code>. Now we have to reconstruct our \(\boldsymbol{\beta}\)s:</p>
<pre><code class=language-julia >betas &#61; mapslices&#40;x -&gt; R_ast^-1 * x, chain_qr&#91;:, namesingroup&#40;chain_qr, :β&#41;,:&#93;.value.data, dims&#61;&#91;2&#93;&#41;
chain_beta &#61; setrange&#40;Chains&#40;betas, &#91;&quot;real_β&#91;&#36;i&#93;&quot; for i in 1:size&#40;Q_ast, 2&#41;&#93;&#41;, 1_001:1:3_000&#41;
chain_qr_reconstructed &#61; hcat&#40;chain_beta, chain_qr&#41;</code></pre><pre><code class="plaintext code-output">Chains MCMC chain (2000×20×4 Array{Float64, 3}):

Iterations        = 1001:1:3000
Number of chains  = 4
Samples per chain = 2000
parameters        = real_β[1], real_β[2], real_β[3], α, β[1], β[2], β[3], σ
internals         = lp, n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size

Summary Statistics
  parameters       mean       std   naive_se      mcse         ess      rhat
      Symbol    Float64   Float64    Float64   Float64     Float64   Float64

   real_β[1]     6.2755    2.2081     0.0247    0.0265   7885.8353    0.9996
   real_β[2]     0.5023    0.0633     0.0007    0.0011   3402.7897    1.0001
   real_β[3]    -0.0715    0.2215     0.0025    0.0041   2942.9498    1.0001
           α    33.2749    7.9295     0.0887    0.1678   2113.0783    1.0003
        β[1]   -49.6645    7.0809     0.0792    0.1498   2117.7218    1.0003
        β[2]    21.8955    3.6100     0.0404    0.0757   2147.1293    1.0002
        β[3]     0.2928    0.9071     0.0101    0.0167   2942.9498    1.0001
           σ    17.8676    0.5988     0.0067    0.0090   4805.0471    0.9999

Quantiles
  parameters       2.5%      25.0%      50.0%      75.0%      97.5%
      Symbol    Float64    Float64    Float64    Float64    Float64

   real_β[1]     1.9200     4.7657     6.3056     7.7812    10.5096
   real_β[2]     0.3778     0.4602     0.5030     0.5456     0.6249
   real_β[3]    -0.5417    -0.2099    -0.0597     0.0770     0.3418
           α    18.4666    27.8142    32.9991    38.4474    49.3556
        β[1]   -63.0827   -54.5222   -49.8503   -45.0637   -35.2238
        β[2]    14.4705    19.5789    21.9879    24.3914    28.6957
        β[3]    -1.3998    -0.3152     0.2446     0.8594     2.2182
           σ    16.7584    17.4485    17.8652    18.2675    19.0575
</code></pre>
<h2 id=non-centered_parametrization ><a href="#non-centered_parametrization" class=header-anchor >Non-Centered Parametrization</a></h2>
<p>Now let&#39;s us explore <strong>Non-Centered Parametrization</strong> &#40;NCP&#41;. This is useful when the posterior&#39;s topology is very difficult to explore as has regions where HMC sampler has to change the step size \(L\) and the \(\epsilon\) factor. This is  I&#39;ve showed one of the most infamous case in <a href="/Bayesian-Julia/pages/5_MCMC/">5. <strong>Markov Chain Monte Carlo &#40;MCMC&#41;</strong></a>: Neal&#39;s Funnel &#40;Neal, 2003&#41;:</p>
<pre><code class=language-julia >using StatsPlots, Distributions, LaTeXStrings
funnel_y &#61; rand&#40;Normal&#40;0, 3&#41;, 10_000&#41;
funnel_x &#61; rand&#40;Normal&#40;&#41;, 10_000&#41; .* exp.&#40;funnel_y / 2&#41;

scatter&#40;&#40;funnel_x, funnel_y&#41;,
        label&#61;false, mc&#61;:steelblue, ma&#61;0.3,
        xlabel&#61;L&quot;X&quot;, ylabel&#61;L&quot;Y&quot;,
        xlims&#61;&#40;-100, 100&#41;&#41;</code></pre>
<p><img src="/Bayesian-Julia/assets/pages/11_Turing_tricks/code/output/funnel.svg" alt=""> <div class=text-center ><em>Neal&#39;s Funnel</em></div> <br/></p>
<p>Here we see that in upper part of the funnel HMC has to take few steps \(L\) and be more liberal with the \(\epsilon\) factor. But, the opposite is in the lower part of the funnel: way more steps \(L\) and be more conservative with the \(\epsilon\) factor.</p>
<p>To see the devil&#39;s funnel &#40;how it is known in some Bayesian circles&#41; in action, let&#39;s code it in Turing and then sample:</p>
<pre><code class=language-julia >@model funnel&#40;&#41; &#61; begin
    y ~ Normal&#40;0, 3&#41;
    x ~ Normal&#40;0, exp&#40;y / 2&#41;&#41;
end

    chain_funnel &#61; sample&#40;funnel&#40;&#41;, NUTS&#40;&#41;, MCMCThreads&#40;&#41;, 2_000, 4&#41;</code></pre><pre><code class="plaintext code-output">Chains MCMC chain (2000×14×4 Array{Float64, 3}):

Iterations        = 1001:1:3000
Number of chains  = 4
Samples per chain = 2000
Wall duration     = 7.55 seconds
Compute duration  = 13.65 seconds
parameters        = y, x
internals         = lp, n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size

Summary Statistics
  parameters      mean       std   naive_se      mcse        ess      rhat   ess_per_sec
      Symbol   Float64   Float64    Float64   Float64    Float64   Float64       Float64

           y    1.3884    2.3810     0.0266    0.1494   160.3485    1.0422       11.7480
           x    0.1935    8.7429     0.0977    0.2901   607.2345    1.0093       44.4893

Quantiles
  parameters       2.5%     25.0%     50.0%     75.0%     97.5%
      Symbol    Float64   Float64   Float64   Float64   Float64

           y    -2.3844   -0.4325    1.2142    2.9793    6.5042
           x   -13.3863   -1.0163   -0.0697    1.1303   16.0996
</code></pre>
<p>Wow, take a look at those <code>rhat</code> values... That sucks: all are above <code>1.01</code> even with 4 parallel chains with 2,000 iterations&#33;</p>
<p>How do we deal with that? We <strong>reparametrize</strong>&#33; Note that we can add two normal distributions in the following manner:</p>
\[ \text{Normal}(\mu, \sigma) = \text{Standard Normal} \cdot \sigma + \mu \]
<p>where the standard normal is the normal with mean \(\mu = 0\) and standard deviation \(\sigma = 1\). This is why is called Non-Centered Parametrization because we &quot;decouple&quot; the parameters and reconstruct them before.</p>
<pre><code class=language-julia >@model ncp_funnel&#40;&#41; &#61; begin
    x̃ ~ Normal&#40;&#41;
    ỹ ~ Normal&#40;&#41;
    y &#61; 3.0 * ỹ         # implies y ~ Normal&#40;0, 3&#41;
    x &#61; exp&#40;y / 2&#41; * x̃  # implies x ~ Normal&#40;0, exp&#40;y / 2&#41;&#41;
end

chain_ncp_funnel &#61; sample&#40;ncp_funnel&#40;&#41;, NUTS&#40;&#41;, MCMCThreads&#40;&#41;, 2_000, 4&#41;</code></pre><pre><code class="plaintext code-output">Chains MCMC chain (2000×14×4 Array{Float64, 3}):

Iterations        = 1001:1:3000
Number of chains  = 4
Samples per chain = 2000
Wall duration     = 7.38 seconds
Compute duration  = 13.68 seconds
parameters        = x̃, ỹ
internals         = lp, n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size

Summary Statistics
  parameters      mean       std   naive_se      mcse         ess      rhat   ess_per_sec
      Symbol   Float64   Float64    Float64   Float64     Float64   Float64       Float64

           x̃   -0.0069    0.9970     0.0111    0.0109   8178.0937    0.9999      597.8139
           ỹ   -0.0047    1.0121     0.0113    0.0100   8018.0031    0.9996      586.1113

Quantiles
  parameters      2.5%     25.0%     50.0%     75.0%     97.5%
      Symbol   Float64   Float64   Float64   Float64   Float64

           x̃   -1.9425   -0.6828    0.0018    0.6641    1.9180
           ỹ   -1.9909   -0.6893    0.0031    0.6811    1.9658
</code></pre>
<p>Much better now: all <code>rhat</code> are well below <code>1.01</code> &#40;or below <code>0.99</code>&#41;.</p>
<p>How we would implement this a real-world model in Turing? Let&#39;s go back to the <code>cheese</code> random-intercept model in <a href="/Bayesian-Julia/pages/10_multilevel_models/">10. <strong>Multilevel Models &#40;a.k.a. Hierarchical Models&#41;</strong></a>. Here was the approach that we took, also known as Centered Parametrization &#40;CP&#41;:</p>
<pre><code class=language-julia >@model varying_intercept&#40;X, idx, y; n_gr&#61;length&#40;unique&#40;idx&#41;&#41;, predictors&#61;size&#40;X, 2&#41;&#41; &#61; begin
    #priors
    α ~ Normal&#40;mean&#40;y&#41;, 2.5 * std&#40;y&#41;&#41;       # population-level intercept
    β ~ filldist&#40;Normal&#40;0, 2&#41;, predictors&#41;  # population-level coefficients
    σ ~ Exponential&#40;1 / std&#40;y&#41;&#41;             # residual SD
    #prior for variance of random intercepts
    #usually requires thoughtful specification
    τ ~ truncated&#40;Cauchy&#40;0, 2&#41;, 0, Inf&#41;     # group-level SDs intercepts
    αⱼ ~ filldist&#40;Normal&#40;0, τ&#41;, n_gr&#41;       # CP group-level intercepts

    #likelihood
    ŷ &#61; α .&#43; X * β .&#43; αⱼ&#91;idx&#93;
    y ~ MvNormal&#40;ŷ, σ&#41;
end;</code></pre>
<p>To perform a Non-Centered Parametrization &#40;NCP&#41; in this model we do as following:</p>
<pre><code class=language-julia >@model varying_intercept_ncp&#40;X, idx, y; n_gr&#61;length&#40;unique&#40;idx&#41;&#41;, predictors&#61;size&#40;X, 2&#41;&#41; &#61; begin
    #priors
    α ~ Normal&#40;mean&#40;y&#41;, 2.5 * std&#40;y&#41;&#41;       # population-level intercept
    β ~ filldist&#40;Normal&#40;0, 2&#41;, predictors&#41;  # population-level coefficients
    σ ~ Exponential&#40;1 / std&#40;y&#41;&#41;             # residual SD

    #prior for variance of random intercepts
    #usually requires thoughtful specification
    τ ~ truncated&#40;Cauchy&#40;0, 2&#41;, 0, Inf&#41;    # group-level SDs intercepts
    zⱼ ~ filldist&#40;Normal&#40;0, 1&#41;, n_gr&#41;      # NCP group-level intercepts

    #likelihood
    ŷ &#61; α .&#43; X * β .&#43; zⱼ&#91;idx&#93; .* τ
    y ~ MvNormal&#40;ŷ, σ&#41;
end;</code></pre>
<p>Here we are using a NCP with the <code>zⱼ</code>s following a standard normal and we reconstruct the group-level intercepts by multiplying the <code>zⱼ</code>s by <code>τ</code>. Since the original <code>αⱼ</code>s had a prior centered on 0 with standard deviation <code>τ</code>, we only have to use the multiplication by <code>τ</code> to get back the <code>αⱼ</code>s.</p>
<p>Now let&#39;s see how NCP compares to the CP. First, let&#39;s redo our CP hierarchical model:</p>
<pre><code class=language-julia >url &#61; &quot;https://raw.githubusercontent.com/storopoli/Bayesian-Julia/master/datasets/cheese.csv&quot;
cheese &#61; CSV.read&#40;HTTP.get&#40;url&#41;.body, DataFrame&#41;

for c in unique&#40;cheese&#91;:, :cheese&#93;&#41;
    cheese&#91;:, &quot;cheese_&#36;c&quot;&#93; &#61; ifelse.&#40;cheese&#91;:, :cheese&#93; .&#61;&#61; c, 1, 0&#41;
end

cheese&#91;:, :background_int&#93; &#61; map&#40;cheese&#91;:, :background&#93;&#41; do b
    b &#61;&#61; &quot;rural&quot; ? 1 :
    b &#61;&#61; &quot;urban&quot; ? 2 : missing
end

X &#61; Matrix&#40;select&#40;cheese, Between&#40;:cheese_A, :cheese_D&#41;&#41;&#41;;
y &#61; cheese&#91;:, :y&#93;;
idx &#61; cheese&#91;:, :background_int&#93;;

model_cp &#61; varying_intercept&#40;X, idx, y&#41;
chain_cp &#61; sample&#40;model_cp, NUTS&#40;&#41;, MCMCThreads&#40;&#41;, 2_000, 4&#41;</code></pre><pre><code class="plaintext code-output">Chains MCMC chain (2000×21×4 Array{Float64, 3}):

Iterations        = 1001:1:3000
Number of chains  = 4
Samples per chain = 2000
Wall duration     = 30.24 seconds
Compute duration  = 58.6 seconds
parameters        = α, β[1], β[2], β[3], β[4], σ, τ, αⱼ[1], αⱼ[2]
internals         = lp, n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size

Summary Statistics
  parameters       mean       std   naive_se      mcse         ess      rhat   ess_per_sec
      Symbol    Float64   Float64    Float64   Float64     Float64   Float64       Float64

           α    70.7190    5.2616     0.0588    0.1773    906.7976    1.0058       15.4749
        β[1]     3.2351    1.2543     0.0140    0.0226   3335.1223    0.9998       56.9153
        β[2]   -11.6323    1.2699     0.0142    0.0218   3482.0497    0.9999       59.4227
        β[3]     7.1701    1.2307     0.0138    0.0207   3306.7974    0.9997       56.4319
        β[4]     1.1979    1.2502     0.0140    0.0206   3513.0851    0.9998       59.9523
           σ     5.9930    0.2745     0.0031    0.0037   5527.6283    1.0004       94.3313
           τ     6.4146    6.6373     0.0742    0.1804   1478.5048    1.0042       25.2313
       αⱼ[1]    -3.4511    5.1655     0.0578    0.1722    952.7034    1.0062       16.2583
       αⱼ[2]     3.7110    5.1772     0.0579    0.1717    960.0203    1.0062       16.3832

Quantiles
  parameters       2.5%      25.0%      50.0%      75.0%     97.5%
      Symbol    Float64    Float64    Float64    Float64   Float64

           α    60.2781    68.3590    70.7779    73.2704   80.9692
        β[1]     0.7285     2.3946     3.2539     4.0834    5.6589
        β[2]   -14.1365   -12.4906   -11.6232   -10.7748   -9.1705
        β[3]     4.7085     6.3426     7.1733     7.9974    9.6151
        β[4]    -1.3057     0.3672     1.2095     2.0532    3.6275
           σ     5.4874     5.8044     5.9858     6.1718    6.5540
           τ     1.9390     3.3318     4.7163     7.2482   20.9105
       αⱼ[1]   -13.4753    -5.8040    -3.4689    -1.2218    6.9789
       αⱼ[2]    -6.1605     1.3716     3.5932     5.8833   14.4133
</code></pre>
<p>Now let&#39;s do the NCP hierarchical model:</p>
<pre><code class=language-julia >model_ncp &#61; varying_intercept_ncp&#40;X, idx, y&#41;
chain_ncp &#61; sample&#40;model_ncp, NUTS&#40;&#41;, MCMCThreads&#40;&#41;, 2_000, 4&#41;</code></pre><pre><code class="plaintext code-output">Chains MCMC chain (2000×21×4 Array{Float64, 3}):

Iterations        = 1001:1:3000
Number of chains  = 4
Samples per chain = 2000
Wall duration     = 32.55 seconds
Compute duration  = 62.67 seconds
parameters        = α, β[1], β[2], β[3], β[4], σ, τ, zⱼ[1], zⱼ[2]
internals         = lp, n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size

Summary Statistics
  parameters       mean       std   naive_se      mcse         ess      rhat   ess_per_sec
      Symbol    Float64   Float64    Float64   Float64     Float64   Float64       Float64

           α    70.8868    3.6980     0.0413    0.1201    944.4853    1.0052       15.0713
        β[1]     3.1683    1.2649     0.0141    0.0277   1599.3589    1.0034       25.5211
        β[2]   -11.6644    1.2595     0.0141    0.0234   2311.3091    1.0028       36.8818
        β[3]     7.0896    1.2638     0.0141    0.0289   1824.2196    1.0026       29.1093
        β[4]     1.1516    1.2785     0.0143    0.0262   1210.2260    1.0041       19.3117
           σ     6.0035    0.2758     0.0031    0.0049   2900.7301    1.0017       46.2873
           τ     5.3971    3.0013     0.0336    0.1287    339.9252    1.0099        5.4242
       zⱼ[1]    -0.8373    0.7752     0.0087    0.0165   1754.7860    1.0000       28.0013
       zⱼ[2]     0.8637    0.7866     0.0088    0.0226   1167.2946    1.0059       18.6266

Quantiles
  parameters       2.5%      25.0%      50.0%      75.0%     97.5%
      Symbol    Float64    Float64    Float64    Float64   Float64

           α    63.1206    68.8006    70.8514    73.0677   78.9521
        β[1]     0.7887     2.2889     3.1632     4.0150    5.6652
        β[2]   -14.0890   -12.5424   -11.6937   -10.7988   -9.1833
        β[3]     4.6131     6.2141     7.1102     7.9595    9.5283
        β[4]    -1.3032     0.2904     1.1481     2.0148    3.6623
           σ     5.4889     5.8138     5.9893     6.1812    6.5681
           τ     1.9159     3.2325     4.5453     6.6889   13.4013
       zⱼ[1]    -2.4647    -1.3441    -0.7969    -0.3060    0.6232
       zⱼ[2]    -0.5411     0.2982     0.8235     1.3713    2.5196
</code></pre>
<p>Notice that some models are better off with a standard Centered Parametrization &#40;as is our <code>cheese</code> case here&#41;. While others are better off with a Non-Centered Parametrization. But now you know how to apply both parametrizations in Turing. Before we conclude, we need to recover our original <code>αⱼ</code>s. We can do this by multiplying <code>zⱼ&#91;idx&#93; .* τ</code>:</p>
<pre><code class=language-julia >τ &#61; summarystats&#40;chain_ncp&#41;&#91;:τ, :mean&#93;
αⱼ &#61; mapslices&#40;x -&gt; x * τ, chain_ncp&#91;:, namesingroup&#40;chain_ncp, :zⱼ&#41;, :&#93;.value.data, dims&#61;&#91;2&#93;&#41;
chain_ncp_reconstructed &#61; hcat&#40;MCMCChains.resetrange&#40;chain_ncp&#41;, Chains&#40;αⱼ, &#91;&quot;αⱼ&#91;&#36;i&#93;&quot; for i in 1:length&#40;unique&#40;idx&#41;&#41;&#93;&#41;&#41;</code></pre><pre><code class="plaintext code-output">Chains MCMC chain (2000×23×4 Array{Float64, 3}):

Iterations        = 1:2000
Number of chains  = 4
Samples per chain = 2000
Wall duration     = 32.55 seconds
Compute duration  = 62.67 seconds
parameters        = α, β[1], β[2], β[3], β[4], σ, τ, zⱼ[1], zⱼ[2], αⱼ[1], αⱼ[2]
internals         = lp, n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size

Summary Statistics
  parameters       mean       std   naive_se      mcse         ess      rhat   ess_per_sec
      Symbol    Float64   Float64    Float64   Float64     Float64   Float64       Float64

           α    70.8868    3.6980     0.0413    0.1201    944.4853    1.0052       15.0713
        β[1]     3.1683    1.2649     0.0141    0.0277   1599.3589    1.0034       25.5211
        β[2]   -11.6644    1.2595     0.0141    0.0234   2311.3091    1.0028       36.8818
        β[3]     7.0896    1.2638     0.0141    0.0289   1824.2196    1.0026       29.1093
        β[4]     1.1516    1.2785     0.0143    0.0262   1210.2260    1.0041       19.3117
           σ     6.0035    0.2758     0.0031    0.0049   2900.7301    1.0017       46.2873
           τ     5.3971    3.0013     0.0336    0.1287    339.9252    1.0099        5.4242
       zⱼ[1]    -0.8373    0.7752     0.0087    0.0165   1754.7860    1.0000       28.0013
       zⱼ[2]     0.8637    0.7866     0.0088    0.0226   1167.2946    1.0059       18.6266
       αⱼ[1]    -4.5192    4.1838     0.0468    0.0889   1754.7860    1.0000       28.0013
       αⱼ[2]     4.6613    4.2455     0.0475    0.1220   1167.2946    1.0059       18.6266

Quantiles
  parameters       2.5%      25.0%      50.0%      75.0%     97.5%
      Symbol    Float64    Float64    Float64    Float64   Float64

           α    63.1206    68.8006    70.8514    73.0677   78.9521
        β[1]     0.7887     2.2889     3.1632     4.0150    5.6652
        β[2]   -14.0890   -12.5424   -11.6937   -10.7988   -9.1833
        β[3]     4.6131     6.2141     7.1102     7.9595    9.5283
        β[4]    -1.3032     0.2904     1.1481     2.0148    3.6623
           σ     5.4889     5.8138     5.9893     6.1812    6.5681
           τ     1.9159     3.2325     4.5453     6.6889   13.4013
       zⱼ[1]    -2.4647    -1.3441    -0.7969    -0.3060    0.6232
       zⱼ[2]    -0.5411     0.2982     0.8235     1.3713    2.5196
       αⱼ[1]   -13.3021    -7.2541    -4.3009    -1.6514    3.3637
       αⱼ[2]    -2.9201     1.6096     4.4446     7.4010   13.5986
</code></pre>
<h2 id=references ><a href="#references" class=header-anchor >References</a></h2>
<p>Neal, Radford M. &#40;2003&#41;. Slice Sampling. The Annals of Statistics, 31&#40;3&#41;, 705–741. Retrieved from https://www.jstor.org/stable/3448413</p>

<div class=page-foot >
  <div class=copyright >
    Last modified: December 29, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
    </div> 
    </div> 
    </div> <!-- end of class page-wrap-->
    
      <script src="/Bayesian-Julia/libs/katex/katex.min.js"></script>
<script src="/Bayesian-Julia/libs/katex/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

    
    
      <script src="/Bayesian-Julia/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>